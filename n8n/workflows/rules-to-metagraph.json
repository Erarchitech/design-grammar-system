{
  "name": "DG Rules -> Metagraph",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dg/rules-ingest",
        "responseMode": "responseNode"
      },
      "id": "1",
      "name": "Ingest Rules",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -700,
        0
      ],
      "webhookId": "dg-rules-ingest"
    },
    {
      "parameters": {
        "keepOnlySet": true,
        "values": {
          "string": [
            {
              "name": "rules_text",
              "value": "={{$json.rules_text || ($json.body && $json.body.rules_text) || ($json.query && $json.query.rules_text) || $json.rules || ''}}"
            },
            {
              "name": "neo4j_user",
              "value": "={{$json.neo4j_user || 'neo4j'}}"
            },
            {
              "name": "neo4j_password",
              "value": "={{$json.neo4j_password || '12345678'}}"
            },
            {
              "name": "project_name",
              "value": "={{$json.project_name || $json.project || 'default-project'}}"
            },
            {
              "name": "ollama_model",
              "value": "={{$json.ollama_model || 'llama3.1'}}"
            },
            {
              "name": "ollama_url",
              "value": "={{$json.ollama_url || 'http://ollama:11434'}}"
            },
            {
              "name": "ollama_keep_alive",
              "value": "={{$json.ollama_keep_alive || '30m'}}"
            },
            {
              "name": "neo4j_url",
              "value": "={{$json.neo4j_url || ($json.body && $json.body.neo4j_url) || ($json.query && $json.query.neo4j_url) || 'http://neo4j:7474'}}"
            },
            {
              "name": "data_service_url",
              "value": "={{$json.data_service_url || 'http://data-service:8000'}}"
            }
          ]
        }
      },
      "id": "2",
      "name": "Set Input Defaults",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        -460,
        0
      ]
    },
    {
      "parameters": {
        "functionCode": "const input = $items(\"Set Input Defaults\")[0].json;\nconst rulesText = (input.rules_text || '')\n  .replace(/[ \\t]+/g, ' ')\n  .replace(/\\n{3,}/g, '\\n\\n')\n  .trim();\nif (!rulesText) {\n  throw new Error('rules_text is required');\n}\nconst prompt = [\n  'Convert design rules into compact JSON. Output JSON only (no markdown, no commentary).',\n  'Schema (all keys required unless noted):',\n  '{\"ontology\":{\"classes\":[{\"name\":\"ClassName\",\"description\":\"\"}],\"data_properties\":[{\"name\":\"height\",\"domain\":\"Building\",\"range\":\"float\",\"units\":\"m\",\"description\":\"\"}],\"object_properties\":[{\"name\":\"adjacentTo\",\"domain\":\"Building\",\"range\":\"Building\",\"description\":\"\"}]},\"rules\":[{\"id\":\"R1\",\"name\":\"Short title\",\"text\":\"original rule text\",\"validationType\":\"geometric|semantic|topological\",\"swrl\":\"SWRL rule\",\"atoms\":{\"body\":[{\"atomType\":\"ClassAtom\",\"predicate\":\"Building\",\"args\":[\"?b\"],\"notes\":\"\"}],\"head\":[{\"atomType\":\"ClassAtom\",\"predicate\":\"HeightCompliant\",\"args\":[\"?b\"],\"notes\":\"\"}]}}]}',\n  'Optional fields: description, units, notes (omit if empty).',\n  'Rules text:',\n  rulesText\n].join(\"\\n\");\nreturn [{ json: { ...input, prompt } }];"
      },
      "id": "3",
      "name": "Build LLM Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -220,
        0
      ]
    },
    {
      "parameters": {
        "url": "={{$items(\"Build LLM Prompt\")[0].json.ollama_url}}/api/generate",
        "jsonParameters": true,
        "options": {
          "timeout": 900000
        },
        "bodyParametersJson": "={{ { \"model\": $items(\"Build LLM Prompt\")[0].json.ollama_model, \"prompt\": $items(\"Build LLM Prompt\")[0].json.prompt, \"stream\": false, \"format\": \"json\", \"keep_alive\": $items(\"Build LLM Prompt\")[0].json.ollama_keep_alive } }}",
        "requestMethod": "POST"
      },
      "id": "4",
      "name": "Ollama Generate",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        20,
        0
      ]
    },
    {
      "parameters": {
        "functionCode": "const input = $items(\"Set Input Defaults\")[0].json;\nconst base = {\n  project_name: input.project_name,\n  neo4j_user: input.neo4j_user,\n  neo4j_password: input.neo4j_password,\n  neo4j_url: input.neo4j_url\n};\nconst raw = $json.response !== undefined ? $json.response : ($json.body !== undefined ? $json.body : $json);\nlet parsed = raw;\ntry {\n  if (typeof raw === 'string') {\n    const trimmed = raw.trim();\n    const start = trimmed.indexOf('{');\n    const end = trimmed.lastIndexOf('}');\n    const jsonText = (start !== -1 && end !== -1) ? trimmed.slice(start, end + 1) : trimmed;\n    parsed = JSON.parse(jsonText);\n  }\n} catch (e) {\n  throw new Error('Ollama did not return valid JSON: ' + e.message);\n}\nreturn [{ json: { ...base, llm: parsed } }];"
      },
      "id": "5",
      "name": "Parse LLM Output",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        260,
        0
      ]
    },
    {
      "parameters": {
        "functionCode": "const llm = $json.llm || {};\nconst ontology = llm.ontology || {};\nconst rulesRaw = Array.isArray(llm.rules) ? llm.rules : [];\nconst classesRaw = Array.isArray(ontology.classes) ? ontology.classes : [];\nconst dataPropsRaw = Array.isArray(ontology.data_properties) ? ontology.data_properties : [];\nconst objectPropsRaw = Array.isArray(ontology.object_properties) ? ontology.object_properties : [];\n\nconst clean = (value) => (typeof value === 'string' ? value.trim() : '');\nconst dedupeBy = (items, keyFn) => {\n  const seen = new Map();\n  for (const item of items) {\n    const key = keyFn(item);\n    if (!key || seen.has(key)) continue;\n    seen.set(key, item);\n  }\n  return Array.from(seen.values());\n};\n\nconst classes = dedupeBy(classesRaw, (c) => clean(c && c.name)).map((c) => ({\n  ...c,\n  name: clean(c && c.name),\n  description: (c && typeof c.description === 'string') ? c.description.trim() : (c && c.description !== undefined ? c.description : '')\n}));\n\nconst dataProps = dedupeBy(dataPropsRaw, (p) => clean(p && p.name)).map((p) => ({\n  ...p,\n  name: clean(p && p.name),\n  domain: clean(p && p.domain) || (p && p.domain) || '',\n  range: clean(p && p.range) || (p && p.range) || '',\n  units: (p && typeof p.units === 'string') ? p.units.trim() : (p && p.units !== undefined ? p.units : ''),\n  description: (p && typeof p.description === 'string') ? p.description.trim() : (p && p.description !== undefined ? p.description : '')\n}));\n\nconst objectProps = dedupeBy(objectPropsRaw, (p) => clean(p && p.name)).map((p) => ({\n  ...p,\n  name: clean(p && p.name),\n  domain: clean(p && p.domain) || (p && p.domain) || '',\n  range: clean(p && p.range) || (p && p.range) || '',\n  description: (p && typeof p.description === 'string') ? p.description.trim() : (p && p.description !== undefined ? p.description : '')\n}));\n\nconst rulesNormalized = rulesRaw.map((r, idx) => {\n  const rule = r || {};\n  const id = clean(rule.id) || `R${idx + 1}`;\n  return { ...rule, id };\n});\n\nconst rules = dedupeBy(rulesNormalized, (r) => clean(r && r.id)).filter((r) => r && r.id);\n\nconst atoms = [];\nfor (const rule of rules) {\n  const ruleId = rule.id;\n  const body = (rule.atoms && Array.isArray(rule.atoms.body)) ? rule.atoms.body : [];\n  const head = (rule.atoms && Array.isArray(rule.atoms.head)) ? rule.atoms.head : [];\n  body.forEach((a, i) => {\n    const predicate = clean(a && (a.predicate || a.class || a.property));\n    if (!predicate) return;\n    atoms.push({\n      atomId: `${ruleId}:body:${i}`,\n      ruleId,\n      side: 'body',\n      atomType: a.atomType || a.type || 'ClassAtom',\n      predicate,\n      args: Array.isArray(a.args) ? a.args : [],\n      notes: a && a.notes ? a.notes : ''\n    });\n  });\n  head.forEach((a, i) => {\n    const predicate = clean(a && (a.predicate || a.class || a.property));\n    if (!predicate) return;\n    atoms.push({\n      atomId: `${ruleId}:head:${i}`,\n      ruleId,\n      side: 'head',\n      atomType: a.atomType || a.type || 'ClassAtom',\n      predicate,\n      args: Array.isArray(a.args) ? a.args : [],\n      notes: a && a.notes ? a.notes : ''\n    });\n  });\n}\n\nconst atomsDeduped = dedupeBy(atoms, (a) => clean(a && a.atomId));\n\nreturn [{\n  json: {\n    project_name: $json.project_name,\n    neo4j_user: $json.neo4j_user,\n    neo4j_password: $json.neo4j_password,\n    neo4j_url: $json.neo4j_url,\n    classes,\n    dataProps,\n    objectProps,\n    rules,\n    atoms: atomsDeduped\n  }\n}];"
      },
      "id": "6",
      "name": "Prepare Graph Payload",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        520,
        0
      ]
    },
    {
      "parameters": {
        "authentication": "basicAuth",
        "url": "={{ ($items(\"Prepare Graph Payload\")[0].json.neo4j_url || 'http://neo4j:7474') + '/db/neo4j/tx/commit' }}",
        "jsonParameters": true,
        "options": {
          "ignoreSslIssues": true,
          "timeout": 900000
        },
        "bodyParametersJson": "={{ { \"statements\": [ { \"statement\": \"UNWIND $classes AS c\\nMERGE (cl:Class {name: c.name, project: $project, graph: 'OntoGraph'})\\nSET cl.description = coalesce(c.description, '')\\nWITH $dataProps AS dataProps, $objectProps AS objectProps, $project AS project\\nUNWIND dataProps AS p\\nMERGE (dp:DataProperty {name: p.name, project: project, graph: 'OntoGraph'})\\nSET dp.domain = p.domain, dp.range = p.range, dp.units = p.units, dp.description = coalesce(p.description, '')\\nWITH dp, p, project, objectProps\\nMATCH (cl:Class {name: p.domain, project: project, graph: 'OntoGraph'})\\nMERGE (cl)-[:HAS_DATA_PROPERTY]->(dp)\\nWITH objectProps, project\\nUNWIND objectProps AS r\\nMERGE (op:ObjectProperty {name: r.name, project: project, graph: 'OntoGraph'})\\nSET op.domain = r.domain, op.range = r.range, op.description = coalesce(r.description, '')\\nWITH op, r, project\\nMATCH (cl:Class {name: r.domain, project: project, graph: 'OntoGraph'})\\nMERGE (cl)-[:HAS_OBJECT_PROPERTY]->(op)\", \"parameters\": { \"project\": $items('Prepare Graph Payload')[0].json.project_name, \"classes\": $items('Prepare Graph Payload')[0].json.classes, \"dataProps\": $items('Prepare Graph Payload')[0].json.dataProps, \"objectProps\": $items('Prepare Graph Payload')[0].json.objectProps } } ] } }}",
        "basicAuthUser": "={{$items(\"Prepare Graph Payload\")[0].json.neo4j_user}}",
        "basicAuthPassword": "={{$items(\"Prepare Graph Payload\")[0].json.neo4j_password}}",
        "requestMethod": "POST"
      },
      "id": "8",
      "name": "Upsert Ontology",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1010,
        0
      ]
    },
    {
      "parameters": {
        "authentication": "basicAuth",
        "url": "={{ ($items(\"Prepare Graph Payload\")[0].json.neo4j_url || 'http://neo4j:7474') + '/db/neo4j/tx/commit' }}",
        "jsonParameters": true,
        "options": {
          "ignoreSslIssues": true,
          "timeout": 900000
        },
        "bodyParametersJson": "={{ { \"statements\": [ { \"statement\": \"UNWIND $rules AS r\\nMERGE (rule:Rule {id: r.id, project: $project, graph: 'Metagraph'})\\nSET rule.name = r.name, rule.text = r.text, rule.swrl = r.swrl, rule.validationType = r.validationType, rule.source = coalesce(r.source, '')\\nWITH $atoms AS atoms, $project AS project\\nUNWIND atoms AS a\\nMERGE (atom:Atom {id: a.atomId, project: project, graph: 'Metagraph'})\\nSET atom.atomType = a.atomType, atom.predicate = a.predicate, atom.args = a.args, atom.side = a.side, atom.ruleId = a.ruleId, atom.notes = a.notes\\nWITH atom, a, project\\nMATCH (rule:Rule {id: a.ruleId, project: project, graph: 'Metagraph'})\\nMERGE (rule)-[:HAS_ATOM {side: a.side}]->(atom)\\nFOREACH (_ IN CASE WHEN a.atomType = 'ClassAtom' THEN [1] ELSE [] END |\\n  MERGE (cls:Class {name: a.predicate, project: project, graph: 'OntoGraph'})\\n  MERGE (atom)-[:REFERS_TO]->(cls)\\n)\\nFOREACH (_ IN CASE WHEN a.atomType = 'DataPropertyAtom' THEN [1] ELSE [] END |\\n  MERGE (dp:DataProperty {name: a.predicate, project: project, graph: 'OntoGraph'})\\n  MERGE (atom)-[:REFERS_TO]->(dp)\\n)\\nFOREACH (_ IN CASE WHEN a.atomType = 'ObjectPropertyAtom' THEN [1] ELSE [] END |\\n  MERGE (op:ObjectProperty {name: a.predicate, project: project, graph: 'OntoGraph'})\\n  MERGE (atom)-[:REFERS_TO]->(op)\\n)\\nFOREACH (_ IN CASE WHEN a.atomType = 'BuiltinAtom' THEN [1] ELSE [] END |\\n  MERGE (bi:Builtin {name: a.predicate, project: project, graph: 'Metagraph'})\\n  MERGE (atom)-[:REFERS_TO]->(bi)\\n)\", \"parameters\": { \"project\": $items('Prepare Graph Payload')[0].json.project_name, \"rules\": $items('Prepare Graph Payload')[0].json.rules, \"atoms\": $items('Prepare Graph Payload')[0].json.atoms } } ] } }}",
        "basicAuthUser": "={{$items(\"Prepare Graph Payload\")[0].json.neo4j_user}}",
        "basicAuthPassword": "={{$items(\"Prepare Graph Payload\")[0].json.neo4j_password}}",
        "requestMethod": "POST"
      },
      "id": "9",
      "name": "Upsert Rules",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1260,
        0
      ]
    },
    {
      "parameters": {
        "functionCode": "const payload = $items(\"Prepare Graph Payload\")[0].json;\nconst cypherStatements = [\n  \"UNWIND $classes AS c\\\\nMERGE (cl:Class {name: c.name, project: $project, graph: 'OntoGraph'})\\\\nSET cl.description = coalesce(c.description, '')\\\\nWITH $dataProps AS dataProps, $objectProps AS objectProps, $project AS project\\\\nUNWIND dataProps AS p\\\\nMERGE (dp:DataProperty {name: p.name, project: project, graph: 'OntoGraph'})\\\\nSET dp.domain = p.domain, dp.range = p.range, dp.units = p.units, dp.description = coalesce(p.description, '')\\\\nWITH dp, p, project, objectProps\\\\nMATCH (cl:Class {name: p.domain, project: project, graph: 'OntoGraph'})\\\\nMERGE (cl)-[:HAS_DATA_PROPERTY]->(dp)\\\\nWITH objectProps, project\\\\nUNWIND objectProps AS r\\\\nMERGE (op:ObjectProperty {name: r.name, project: project, graph: 'OntoGraph'})\\\\nSET op.domain = r.domain, op.range = r.range, op.description = coalesce(r.description, '')\\\\nWITH op, r, project\\\\nMATCH (cl:Class {name: r.domain, project: project, graph: 'OntoGraph'})\\\\nMERGE (cl)-[:HAS_OBJECT_PROPERTY]->(op)\",\n  \"UNWIND $rules AS r\\\\nMERGE (rule:Rule {id: r.id, project: $project, graph: 'Metagraph'})\\\\nSET rule.name = r.name, rule.text = r.text, rule.swrl = r.swrl, rule.validationType = r.validationType, rule.source = coalesce(r.source, '')\\\\nWITH $atoms AS atoms, $project AS project\\\\nUNWIND atoms AS a\\\\nMERGE (atom:Atom {id: a.atomId, project: project, graph: 'Metagraph'})\\\\nSET atom.atomType = a.atomType, atom.predicate = a.predicate, atom.args = a.args, atom.side = a.side, atom.ruleId = a.ruleId, atom.notes = a.notes\\\\nWITH atom, a, project\\\\nMATCH (rule:Rule {id: a.ruleId, project: project, graph: 'Metagraph'})\\\\nMERGE (rule)-[:HAS_ATOM {side: a.side}]->(atom)\\\\nFOREACH (_ IN CASE WHEN a.atomType = 'ClassAtom' THEN [1] ELSE [] END |\\\\n  MERGE (cls:Class {name: a.predicate, project: project, graph: 'OntoGraph'})\\\\n  MERGE (atom)-[:REFERS_TO]->(cls)\\\\n)\\\\nFOREACH (_ IN CASE WHEN a.atomType = 'DataPropertyAtom' THEN [1] ELSE [] END |\\\\n  MERGE (dp:DataProperty {name: a.predicate, project: project, graph: 'OntoGraph'})\\\\n  MERGE (atom)-[:REFERS_TO]->(dp)\\\\n)\\\\nFOREACH (_ IN CASE WHEN a.atomType = 'ObjectPropertyAtom' THEN [1] ELSE [] END |\\\\n  MERGE (op:ObjectProperty {name: a.predicate, project: project, graph: 'OntoGraph'})\\\\n  MERGE (atom)-[:REFERS_TO]->(op)\\\\n)\\\\nFOREACH (_ IN CASE WHEN a.atomType = 'BuiltinAtom' THEN [1] ELSE [] END |\\\\n  MERGE (bi:Builtin {name: a.predicate, project: project, graph: 'Metagraph'})\\\\n  MERGE (atom)-[:REFERS_TO]->(bi)\\\\n)\"\n];\nreturn [{\n  json: {\n    status: \"ok\",\n    project: payload.project_name,\n    database: \"neo4j\",\n    graphs: { ontology: \"OntoGraph\", rules: \"Metagraph\" },\n    counts: {\n      rules: (payload.rules || []).length,\n      atoms: (payload.atoms || []).length,\n      classes: (payload.classes || []).length,\n      data_properties: (payload.dataProps || []).length,\n      object_properties: (payload.objectProps || []).length\n    },\n    cypher: cypherStatements\n  }\n}];"
      },
      "id": "10",
      "name": "Build Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1510,
        0
      ]
    },
    {
      "parameters": {
        "mode": "passThrough"
      },
      "id": "12",
      "name": "Pass Payload",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 1,
      "position": [
        1135,
        0
      ]
    },
    {
      "parameters": {
        "url": "={{($items(\"Set Input Defaults\")[0].json.data_service_url || 'http://data-service:8000') + '/execution-result'}}",
        "jsonParameters": true,
        "bodyParametersJson": "={{ { \"executionId\": $execution.id, \"status\": \"completed\", \"workflow\": \"rules-ingest\", \"payload\": $json } }}",
        "requestMethod": "POST"
      },
      "id": "store",
      "name": "Store Result",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1680,
        0
      ]
    },
    {
      "parameters": {
        "responseCode": 200,
        "responseData": "={{ { \"status\": \"accepted\", \"executionId\": $execution.id } }}"
      },
      "id": "ack",
      "name": "Respond Ack",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        -340,
        -120
      ]
    },
    {
      "parameters": {
        "url": "={{($items(\"Set Input Defaults\")[0].json.data_service_url || 'http://data-service:8000') + '/execution-result'}}",
        "jsonParameters": true,
        "bodyParametersJson": "={{ { \"executionId\": $execution.id, \"status\": \"running\", \"workflow\": \"rules-ingest\", \"step\": 1, \"progress\": 20, \"message\": \"Workflow started\", \"payload\": {} } }}",
        "requestMethod": "POST"
      },
      "id": "mark",
      "name": "Mark Running",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -120,
        -120
      ]
    },
    {
      "parameters": {
        "url": "={{($items(\"Set Input Defaults\")[0].json.data_service_url || 'http://data-service:8000') + '/execution-result'}}",
        "jsonParameters": true,
        "bodyParametersJson": "={{ { \"executionId\": $execution.id, \"status\": \"running\", \"workflow\": \"rules-ingest\", \"step\": 2, \"progress\": 40, \"message\": \"Parsing rules\" } }}",
        "requestMethod": "POST"
      },
      "id": "step2",
      "name": "Mark Step 2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -100,
        -120
      ]
    },
    {
      "parameters": {
        "url": "={{($items(\"Set Input Defaults\")[0].json.data_service_url || 'http://data-service:8000') + '/execution-result'}}",
        "jsonParameters": true,
        "bodyParametersJson": "={{ { \"executionId\": $execution.id, \"status\": \"running\", \"workflow\": \"rules-ingest\", \"step\": 3, \"progress\": 60, \"message\": \"Writing ontology\" } }}",
        "requestMethod": "POST"
      },
      "id": "step3",
      "name": "Mark Step 3",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        760,
        -120
      ]
    },
    {
      "parameters": {
        "url": "={{($items(\"Set Input Defaults\")[0].json.data_service_url || 'http://data-service:8000') + '/execution-result'}}",
        "jsonParameters": true,
        "bodyParametersJson": "={{ { \"executionId\": $execution.id, \"status\": \"running\", \"workflow\": \"rules-ingest\", \"step\": 4, \"progress\": 80, \"message\": \"Writing rules\" } }}",
        "requestMethod": "POST"
      },
      "id": "step4",
      "name": "Mark Step 4",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        1180,
        -120
      ]
    }
  ],
  "connections": {
    "Ingest Rules": {
      "main": [
        [
          {
            "node": "Set Input Defaults",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Input Defaults": {
      "main": [
        [
          {
            "node": "Respond Ack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build LLM Prompt": {
      "main": [
        [
          {
            "node": "Mark Step 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Generate": {
      "main": [
        [
          {
            "node": "Parse LLM Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Output": {
      "main": [
        [
          {
            "node": "Prepare Graph Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Graph Payload": {
      "main": [
        [
          {
            "node": "Mark Step 3",
            "type": "main",
            "index": 0
          },
          {
            "node": "Pass Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Ontology": {
      "main": [
        [
          {
            "node": "Pass Payload",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Upsert Rules": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Response": {
      "main": [
        [
          {
            "node": "Store Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass Payload": {
      "main": [
        [
          {
            "node": "Mark Step 4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Result": {
      "main": []
    },
    "Respond Ack": {
      "main": [
        [
          {
            "node": "Mark Running",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Running": {
      "main": [
        [
          {
            "node": "Build LLM Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Step 2": {
      "main": [
        [
          {
            "node": "Ollama Generate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Step 3": {
      "main": [
        [
          {
            "node": "Upsert Ontology",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Step 4": {
      "main": [
        [
          {
            "node": "Upsert Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  }
}
