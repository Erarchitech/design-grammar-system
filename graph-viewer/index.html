<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Neo4j Graph Viewer</title>
    <style>
      :root { --bg: #0f1117; --fg: #e6e6e6; --panel: #171a22; --accent: #5fd0ff; --muted: #9aa4b2; }
      body { margin: 0; font-family: Arial, sans-serif; background: var(--bg); color: var(--fg); }
      #app { display: flex; height: 100vh; }
      #left { width: 360px; padding: 16px; background: var(--panel); box-sizing: border-box; border-right: 1px solid #2a2f3a; overflow: auto; }
      #viz { flex: 1; margin-right: 380px; }
      #right {
        width: 380px;
        padding: 16px;
        background: #ffffff;
        color: #1a1a1a;
        box-sizing: border-box;
        border-left: 1px solid #e5e7eb;
        overflow: auto;
        position: fixed;
        right: 0;
        top: 0;
        height: 100vh;
        transform: translateX(100%);
        transition: transform 200ms ease-out;
      }
      #right.open { transform: translateX(0); }
      label { display: block; margin-top: 12px; font-size: 12px; color: var(--muted); }
      input, textarea { width: 100%; margin-top: 6px; background: #0f1117; color: var(--fg); border: 1px solid #2a2f3a; padding: 8px; border-radius: 6px; }
      button { margin-top: 12px; width: 100%; background: var(--accent); color: #0f1117; border: none; padding: 10px; border-radius: 6px; font-weight: bold; cursor: pointer; }
      .hint, .status { font-size: 12px; color: var(--muted); margin-top: 8px; }
      .panel-title { font-size: 18px; font-weight: 700; margin: 0 0 12px 0; }
      .chip { display: inline-block; padding: 4px 10px; border-radius: 999px; background: #ffb36b; color: #1a1a1a; font-weight: 600; font-size: 12px; margin-bottom: 12px; }
      .table { width: 100%; border-collapse: collapse; }
      .table th, .table td { text-align: left; padding: 8px 6px; border-bottom: 1px solid #e5e7eb; font-size: 13px; }
      .table th { color: #6b7280; font-weight: 600; }
      .value { font-family: "Courier New", monospace; font-size: 12px; color: #111827; word-break: break-all; }
      .empty { color: #6b7280; font-size: 13px; }
      .edit-btn { margin-right: 4px; background: #e5e7eb; border: none; border-radius: 4px; padding: 1px 2px; cursor: pointer; font-size: 9px; line-height: 1; width: 16px; }
      .edit-btn:hover { background: #d1d5db; }
      .add-btn { margin-top: 10px; background: #111827; color: #ffffff; border: none; padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; }
      .edit-wrap { position: relative; width: 100%; display: flex; align-items: center; }
      .edit-input { width: 100%; padding-right: 32px; box-sizing: border-box; background: #ffffff; color: #111827; border: 1px solid #d1d5db; border-radius: 6px; padding: 6px 28px 6px 8px; font-family: "Courier New", monospace; font-size: 12px; }
      .save-btn { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); background: #e5e7eb; border: none; border-radius: 4px; padding: 0 4px; height: 20px; line-height: 20px; cursor: pointer; font-size: 10px; }
      .progress { margin-top: 12px; height: 8px; background: #0f1117; border: 1px solid #2a2f3a; border-radius: 999px; overflow: hidden; }
      .progress > div { height: 100%; background: #5fd0ff; width: 0%; transition: width 250ms ease; }
      .steps { margin-top: 8px; font-size: 12px; color: var(--muted); }
      .steps div.active { color: #e6e6e6; }
      .danger-btn { margin-top: 8px; background: #b91c1c; color: #ffffff; border: none; padding: 8px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; }
      .context-menu { position: fixed; z-index: 1000; background: #ffffff; color: #111827; border: 1px solid #e5e7eb; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
      .context-menu button { display: block; width: 100%; padding: 6px 10px; border: none; background: transparent; text-align: left; cursor: pointer; }
      .context-menu button:hover { background: #f3f4f6; }
    </style>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/neovis.js/dist/neovis.js"></script>
    <script src="/config.js"></script>
  </head>
  <body>
    <div id="app"></div>
    <script>
      const e = React.createElement;

      function normalizeValue(v) {
        if (Array.isArray(v)) return v.map(normalizeValue);
        if (v && typeof v === "object") {
          if (Object.prototype.hasOwnProperty.call(v, "low") && Object.prototype.hasOwnProperty.call(v, "high")) {
            return typeof v.toString === "function" ? v.toString() : v.low;
          }
          const out = {};
          for (const k in v) out[k] = normalizeValue(v[k]);
          return out;
        }
        return v;
      }

      function extractProps(item) {
        if (!item) return {};
        if (item.raw && item.raw.properties) return normalizeValue(item.raw.properties);
        if (item.properties) return normalizeValue(item.properties);
        const out = {};
        for (const k in item) {
          if (typeof item[k] !== "function") out[k] = normalizeValue(item[k]);
        }
        return out;
      }

      function buildDetails(type, label, id, props) {
        return { type, label, id, props };
      }

      function App() {
        const [graphView, setGraphView] = React.useState("OntoGraph");
        const buildCypher = (view) => {
          if (view === "MetaGraph") {
            return (
              "MATCH (r:Rule {graph:'Metagraph'}) " +
              "OPTIONAL MATCH (r)-[ha:HAS_ATOM]->(a:Atom {graph:'Metagraph'}) " +
              "OPTIONAL MATCH (a)-[ref:REFERS_TO]->(x {graph:'Metagraph'}) " +
              "RETURN r,ha,a,ref,x"
            );
          }
          return (
            "MATCH (c:Class {graph:'OntoGraph'}) " +
            "OPTIONAL MATCH (c)-[hp:HAS_DATA_PROPERTY|HAS_OBJECT_PROPERTY]->(p {graph:'OntoGraph'}) " +
            "RETURN c,hp,p"
          );
        };
        const [cypher, setCypher] = React.useState(buildCypher("OntoGraph"));
        const [mode, setMode] = React.useState("ingest");
        const [rulesText, setRulesText] = React.useState("");
        const [queryText, setQueryText] = React.useState("");
        const [responseText, setResponseText] = React.useState("");
        const [responseCypher, setResponseCypher] = React.useState("");
        const [status, setStatus] = React.useState("Ready");
        const [isRunning, setIsRunning] = React.useState(false);
        const [selected, setSelected] = React.useState(null);
        const [editingKey, setEditingKey] = React.useState(null);
        const [editingValue, setEditingValue] = React.useState("");
        const [progress, setProgress] = React.useState(0);
        const [step, setStep] = React.useState(0);
        const [stepTimes, setStepTimes] = React.useState([]);
        const [tick, setTick] = React.useState(0);
        const [contextMenu, setContextMenu] = React.useState(null);

        const vizRef = React.useRef(null);
        const stepRef = React.useRef(step);
        const stepStartedAtRef = React.useRef(null);
        const pollRef = React.useRef(null);

        const ingestSteps = [
          "Send rules",
          "LLM parse",
          "Write ontology",
          "Write rules",
          "Reload graph"
        ];
        const querySteps = [
          "Send prompt",
          "Generate cypher",
          "Query graph",
          "Generate response",
          "Complete"
        ];
        const steps = mode === "query" ? querySteps : ingestSteps;

        React.useEffect(() => {
          stepRef.current = step;
        }, [step]);

        React.useEffect(() => {
          setProgress(0);
          setWorkflowStep(0);
          setStepTimes(Array(steps.length).fill(null));
          setStatus("Ready");
          setResponseText("");
          setResponseCypher("");
          setIsRunning(false);
          if (pollRef.current) {
            clearTimeout(pollRef.current);
            pollRef.current = null;
          }
        }, [mode]);

        React.useEffect(() => {
          if (step <= 0) return;
          const id = setInterval(() => setTick((t) => t + 1), 200);
          return () => clearInterval(id);
        }, [step]);

        const roundSeconds = (ms) => Math.round((ms / 1000) * 10) / 10;

        const setWorkflowStep = (nextStep) => {
          const now = Date.now();
          const currentStep = stepRef.current;
          if (currentStep > 0 && stepStartedAtRef.current) {
            const elapsed = roundSeconds(now - stepStartedAtRef.current);
            setStepTimes((times) => {
              const next = times.length ? times.slice() : Array(steps.length).fill(null);
              next[currentStep - 1] = elapsed;
              return next;
            });
          }
          if (nextStep > 0) {
            stepStartedAtRef.current = now;
          } else {
            stepStartedAtRef.current = null;
          }
          stepRef.current = nextStep;
          setStep(nextStep);
        };

        const finalizeWorkflowStep = () => {
          const now = Date.now();
          const currentStep = stepRef.current;
          if (currentStep > 0 && stepStartedAtRef.current) {
            const elapsed = roundSeconds(now - stepStartedAtRef.current);
            setStepTimes((times) => {
              const next = times.length ? times.slice() : Array(steps.length).fill(null);
              next[currentStep - 1] = elapsed;
              return next;
            });
          }
          stepStartedAtRef.current = null;
        };

        const clearPoll = () => {
          if (pollRef.current) {
            clearTimeout(pollRef.current);
            pollRef.current = null;
          }
        };

        const normalizeBaseUrl = (base) => {
          if (!base) return "";
          return base.endsWith("/") ? base.slice(0, -1) : base;
        };

        const applyProgressUpdate = (data, modeType) => {
          if (!data) return;
          const stepValue = Number(data.step ?? data.payload?.step);
          if (Number.isFinite(stepValue) && stepValue > 0 && stepValue <= steps.length && stepValue !== stepRef.current) {
            setWorkflowStep(stepValue);
          }
          const progressValue = data.progress ?? data.payload?.progress;
          if (typeof progressValue === "number" && Number.isFinite(progressValue)) {
            const clamped = Math.max(0, Math.min(100, progressValue));
            setProgress(clamped);
          }
          const message = data.message ?? data.payload?.message;
          if (typeof message === "string" && message.trim()) {
            setStatus(message);
          } else if (data.status === "running") {
            setStatus("Workflow running...");
          }
        };

        const startPollingResult = (executionId, modeType) => {
          const cfg = window.GRAPH_CONFIG || {};
          const base = normalizeBaseUrl(cfg.dataServiceUrl || "/data-service");
          const poll = async () => {
            try {
              const res = await fetch(`${base}/execution-result/${executionId}`);
              if (!res.ok) {
                setStatus(`Polling error: ${res.status}`);
              } else {
                const data = await res.json();
                const status = data?.status || "running";
                if (status !== "completed" && status !== "cancelled" && status !== "failed") {
                  applyProgressUpdate(data, modeType);
                }
                if (status === "completed") {
                  const payload = data?.payload || {};
                  if (modeType === "query") {
                    setResponseText(payload.answer || payload.response || "");
                    setResponseCypher(payload.cypher || "");
                  } else {
                    setResponseText("The Rule ingesting completed successfully");
                    const cypherValue = Array.isArray(payload.cypher)
                      ? payload.cypher.join("\n\n")
                      : (payload.cypher || "");
                    setResponseCypher(cypherValue);
                  }
                  setWorkflowStep(5); setProgress(100);
                  setStatus("Workflow completed");
                  finalizeWorkflowStep();
                  setIsRunning(false);
                  clearPoll();
                  return;
                }
                if (status === "cancelled") {
                  setStatus("Workflow cancelled");
                  finalizeWorkflowStep();
                  setIsRunning(false);
                  clearPoll();
                  return;
                }
                if (status === "failed") {
                  setStatus("Workflow failed");
                  setIsRunning(false);
                  clearPoll();
                  return;
                }
              }
            } catch (err) {
              setStatus("Polling failed: " + err.message);
            }
            pollRef.current = setTimeout(poll, 1500);
          };
          clearPoll();
          poll();
        };

        const startPollingLatest = (workflowKey, modeType) => {
          const cfg = window.GRAPH_CONFIG || {};
          const base = normalizeBaseUrl(cfg.dataServiceUrl || "/data-service");
          const poll = async () => {
            try {
              const res = await fetch(`${base}/execution-result/latest/${workflowKey}`);
              if (!res.ok) {
                setStatus(`Polling error: ${res.status}`);
              } else {
                const data = await res.json();
                const status = data?.status || "running";
                if (status !== "completed" && status !== "cancelled" && status !== "failed") {
                  applyProgressUpdate(data, modeType);
                }
                if (status === "completed") {
                  const payload = data?.payload || {};
                  if (modeType === "query") {
                    setResponseText(payload.answer || payload.response || "");
                    setResponseCypher(payload.cypher || "");
                  } else {
                    setResponseText("The Rule ingesting completed successfully");
                    const cypherValue = Array.isArray(payload.cypher)
                      ? payload.cypher.join("\n\n")
                      : (payload.cypher || "");
                    setResponseCypher(cypherValue);
                  }
                  setWorkflowStep(5); setProgress(100);
                  setStatus("Workflow completed");
                  finalizeWorkflowStep();
                  setIsRunning(false);
                  clearPoll();
                  return;
                }
                if (status === "cancelled") {
                  setStatus("Workflow cancelled");
                  finalizeWorkflowStep();
                  setIsRunning(false);
                  clearPoll();
                  return;
                }
                if (status === "failed") {
                  setStatus("Workflow failed");
                  setIsRunning(false);
                  clearPoll();
                  return;
                }
                if (status === "unknown") {
                  setStatus("Workflow running...");
                }
              }
            } catch (err) {
              setStatus("Polling failed: " + err.message);
            }
            pollRef.current = setTimeout(poll, 1500);
          };
          clearPoll();
          poll();
        };

        const getNode = (id) => {
          const data = vizRef.current?._data?.nodes;
          if (!data) return null;
          return data.get(id) || data.get(String(id)) || data.get(Number(id));
        };

        const getEdge = (id) => {
          const data = vizRef.current?._data?.edges;
          if (!data) return null;
          return data.get(id) || data.get(String(id)) || data.get(Number(id));
        };

        const fetchNodeProps = async (id) => {
          const cfg = window.GRAPH_CONFIG || {};
          const url = (cfg.neo4jHttp || "/neo4j") + "/db/neo4j/tx/commit";
          const auth = btoa(`${cfg.neo4jUser}:${cfg.neo4jPassword}`);
          const body = {
            statements: [
              {
                statement: "MATCH (n) WHERE id(n) = $id RETURN properties(n) AS props, labels(n) AS labels",
                parameters: { id: Number(id) }
              }
            ]
          };
          const res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json", "Authorization": "Basic " + auth },
            body: JSON.stringify(body)
          });
          const json = await res.json();
          const row = json?.results?.[0]?.data?.[0]?.row;
          if (!row) return null;
          return { props: normalizeValue(row[0] || {}), labels: row[1] || [] };
        };

        const fetchEdgeProps = async (id) => {
          const cfg = window.GRAPH_CONFIG || {};
          const url = (cfg.neo4jHttp || "/neo4j") + "/db/neo4j/tx/commit";
          const auth = btoa(`${cfg.neo4jUser}:${cfg.neo4jPassword}`);
          const body = {
            statements: [
              {
                statement: "MATCH ()-[r]->() WHERE id(r) = $id RETURN properties(r) AS props, type(r) AS type",
                parameters: { id: Number(id) }
              }
            ]
          };
          const res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json", "Authorization": "Basic " + auth },
            body: JSON.stringify(body)
          });
          const json = await res.json();
          const row = json?.results?.[0]?.data?.[0]?.row;
          if (!row) return null;
          return { props: normalizeValue(row[0] || {}), type: row[1] || "Relationship" };
        };

        const parseInputValue = (input) => {
          const trimmed = (input || "").trim();
          if (trimmed.length === 0) return "";
          try {
            return JSON.parse(trimmed);
          } catch (_) {
            if (/^-?\d+(\.\d+)?$/.test(trimmed)) return Number(trimmed);
            if (trimmed.toLowerCase() === "true") return true;
            if (trimmed.toLowerCase() === "false") return false;
            return trimmed;
          }
        };

        const updateNodeProp = async (id, key, value) => {
          const cfg = window.GRAPH_CONFIG || {};
          const url = (cfg.neo4jHttp || "/neo4j") + "/db/neo4j/tx/commit";
          const auth = btoa(`${cfg.neo4jUser}:${cfg.neo4jPassword}`);
          const body = {
            statements: [
              {
                statement: "MATCH (n) WHERE id(n) = $id SET n[$key] = $value RETURN properties(n) AS props, labels(n) AS labels",
                parameters: { id: Number(id), key, value }
              }
            ]
          };
          const res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json", "Authorization": "Basic " + auth },
            body: JSON.stringify(body)
          });
          const json = await res.json();
          const row = json?.results?.[0]?.data?.[0]?.row;
          if (!row) return null;
          return { props: normalizeValue(row[0] || {}), labels: row[1] || [] };
        };

        const deleteNode = async (id) => {
          const cfg = window.GRAPH_CONFIG || {};
          const url = (cfg.neo4jHttp || "/neo4j") + "/db/neo4j/tx/commit";
          const auth = btoa(`${cfg.neo4jUser}:${cfg.neo4jPassword}`);
          const body = {
            statements: [
              { statement: "MATCH (n) WHERE id(n) = $id DETACH DELETE n", parameters: { id: Number(id) } }
            ]
          };
          await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json", "Authorization": "Basic " + auth },
            body: JSON.stringify(body)
          });
        };

        const clearGraph = async (graphName) => {
          const cfg = window.GRAPH_CONFIG || {};
          const url = (cfg.neo4jHttp || "/neo4j") + "/db/neo4j/tx/commit";
          const auth = btoa(`${cfg.neo4jUser}:${cfg.neo4jPassword}`);
          const body = {
            statements: [
              { statement: "MATCH (n {graph: $graph}) DETACH DELETE n", parameters: { graph: graphName } }
            ]
          };
          await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json", "Authorization": "Basic " + auth },
            body: JSON.stringify(body)
          });
        };

        const bindEvents = () => {
          const viz = vizRef.current;
          if (!viz) return false;
          const net = viz._network || viz.network;
          if (!net) return false;

          net.off("click");
          net.off("oncontext");
          net.on("click", async (params) => {
            setContextMenu(null);
            if (params.nodes && params.nodes.length) {
              const nodeId = params.nodes[0];
              const node = getNode(nodeId);
              let props = extractProps(node);
              let label = node?.label || node?.group || "Node";
              if (Object.keys(props || {}).length === 0) {
                const fetched = await fetchNodeProps(nodeId);
                if (fetched) {
                  props = fetched.props;
                  label = fetched.labels?.[0] || label;
                }
              }
              setSelected(buildDetails("node", label, nodeId, props));
              setEditingKey(null);
              setEditingValue("");
              return;
            }
            if (params.edges && params.edges.length) {
              const edgeId = params.edges[0];
              const edge = getEdge(edgeId);
              let props = extractProps(edge);
              let label = edge?.label || edge?.type || edge?.raw?.type || "Relationship";
              if (Object.keys(props || {}).length === 0) {
                const fetched = await fetchEdgeProps(edgeId);
                if (fetched) {
                  props = fetched.props;
                  label = fetched.type || label;
                }
              }
              setSelected(buildDetails("edge", label, edgeId, props));
              setEditingKey(null);
              setEditingValue("");
              return;
            }
            setSelected(null);
          });

          net.on("oncontext", (params) => {
            params.event.preventDefault();
            if (params.nodes && params.nodes.length) {
              const nodeId = params.nodes[0];
              setContextMenu({ x: params.event.clientX, y: params.event.clientY, nodeId });
            } else {
              setContextMenu(null);
            }
          });

          return true;
        };

        const applyEdgeLabels = () => {
          const rels = vizRef.current?._data?.edges;
          if (!rels) return false;
          rels.forEach((edge, id) => {
            const label = edge.label || edge.type || edge.raw?.type;
            if (label && edge.label !== label) {
              rels.update({ id, label });
            }
          });
          return true;
        };

        const run = (overrideCypher, opts = {}) => {
          const runOptions = opts || {};
          const isEvent = overrideCypher && typeof overrideCypher === "object" && typeof overrideCypher.preventDefault === "function";
          const queryOverride = isEvent ? null : overrideCypher;
          const cfg = window.GRAPH_CONFIG || {};
          if (!cfg.neo4jUri || !cfg.neo4jUser) {
            setStatus("Missing NEO4J config. Check config.js");
            return Promise.resolve(false);
          }
          return new Promise((resolve) => {
            let settled = false;
            const finish = (ok) => {
              if (settled) return;
              settled = true;
              resolve(ok);
            };
            try {
              const query = typeof queryOverride === "string" ? queryOverride : cypher;
              const config = {
                containerId: "viz",
                neo4j: {
                  serverUrl: cfg.neo4jUri,
                  serverUser: cfg.neo4jUser,
                  serverPassword: cfg.neo4jPassword,
                  driverConfig: cfg.driverConfig || {}
                },
                visConfig: {
                  nodes: {
                    shape: "dot",
                    size: 18,
                    font: { color: "#8fd3ff", size: 12, strokeWidth: 0 }
                  },
                  edges: {
                    arrows: { to: { enabled: true } },
                    font: { align: "middle", color: "#9fb6c9", size: 11, strokeWidth: 0, vadjust: -5 },
                    smooth: { type: "dynamic" }
                  },
                  physics: { stabilization: false },
                  groups: cfg.visGroups || {}
                },
                labels: cfg.labels || {},
                relationships: cfg.relationships || {},
                initialCypher: query
              };

              if (vizRef.current) {
                vizRef.current.clearNetwork();
              }
              vizRef.current = new NeoVis.default(config);

              vizRef.current.registerOnEvent("completed", () => {
                applyEdgeLabels();
                bindEvents();
                if (!runOptions.silentStatus) {
                  setStatus("Query executed");
                }
                finish(true);
              });

              vizRef.current.registerOnEvent("error", (e) => {
                try { console.error("NeoVis error", e); } catch (_) {}
                const msg = e?.message || e?.error || (() => { try { return JSON.stringify(e); } catch { return "unknown"; } })();
                if (!runOptions.silentStatus) {
                  setStatus("Neo4j error: " + msg);
                }
                finish(false);
              });

              vizRef.current.render();
            } catch (err) {
              if (!runOptions.silentStatus) {
                setStatus("Error: " + err.message);
              }
              finish(false);
            }
          });
        };

        const sendRules = async () => {
          const cfg = window.GRAPH_CONFIG || {};
          if (!rulesText.trim()) {
            setStatus("Rules text is required");
            return;
          }
          if (isRunning) return;
          let asyncMode = false;
          setProgress(0);
          setWorkflowStep(0);
          setStepTimes(Array(ingestSteps.length).fill(null));
          setResponseText("");
          setResponseCypher("");
          setStatus("Sending rules...");
          setIsRunning(true);

          try {
            setWorkflowStep(1); setProgress(20);
            const headers = { "Content-Type": "application/json" };
            if (cfg.n8nUser && cfg.n8nPassword) {
              headers["Authorization"] = "Basic " + btoa(`${cfg.n8nUser}:${cfg.n8nPassword}`);
            }
            const resPromise = fetch(cfg.n8nWebhook || "/n8n/webhook/dg/rules-ingest", {
              method: "POST",
              headers,
              body: JSON.stringify({ rules_text: rulesText })
            });
            const res = await resPromise;
            const rawText = await res.text();
            let data = null;
            if (rawText) {
              try { data = JSON.parse(rawText); } catch (_) {}
            }
            if (!res.ok) {
              setStatus("Workflow error: " + (data?.message || rawText || res.status));
              finalizeWorkflowStep();
              return;
            }
            if (data?.status === "accepted" && data?.executionId) {
              asyncMode = true;
              setStatus("Workflow running...");
              startPollingResult(data.executionId, "ingest");
              return;
            }
            if (data?.status === "accepted" && !data?.executionId) {
              asyncMode = true;
              setStatus("Workflow running...");
              startPollingLatest("rules-ingest", "ingest");
              return;
            }
            const isIntermediateResponse = data &&
              !data.answer &&
              !data.response &&
              !data.cypher &&
              (data.rules_text || data.ollama_model || data.neo4j_url);
            if (isIntermediateResponse) {
              asyncMode = true;
              setStatus("Workflow running...");
              startPollingLatest("rules-ingest", "ingest");
              return;
            }
            setWorkflowStep(4); setProgress(80);
            setStatus("Reloading graph...");
            await run(undefined, { silentStatus: true });
            setWorkflowStep(5); setProgress(100);
            setResponseText("The Rule ingesting completed successfully");
            const cypherValue = Array.isArray(data?.cypher)
              ? data.cypher.join("\n\n")
              : (data?.cypher || "");
            setResponseCypher(cypherValue);
            setStatus("Workflow completed");
            finalizeWorkflowStep();
          } catch (err) {
            setStatus("Request failed: " + err.message);
            finalizeWorkflowStep();
          } finally {
            if (!asyncMode) {
              setIsRunning(false);
            }
          }
        };

        const requestGrammar = async () => {
          const cfg = window.GRAPH_CONFIG || {};
          if (!queryText.trim()) {
            setStatus("Prompt is required");
            return;
          }
          if (isRunning) return;
          let asyncMode = false;
          setProgress(0);
          setWorkflowStep(0);
          setStepTimes(Array(querySteps.length).fill(null));
          setResponseText("");
          setResponseCypher("");
          setStatus("Sending prompt...");
          setIsRunning(true);

          try {
            setWorkflowStep(1); setProgress(20);
            const headers = { "Content-Type": "application/json" };
            if (cfg.n8nUser && cfg.n8nPassword) {
              headers["Authorization"] = "Basic " + btoa(`${cfg.n8nUser}:${cfg.n8nPassword}`);
            }
            const primaryUrl = cfg.n8nQueryWebhook || "/n8n/webhook/dg/graph-query";
            const fallbackUrl = primaryUrl.includes("/webhook/")
              ? primaryUrl.replace("/webhook/", "/webhook-test/")
              : null;
            const callWebhook = async (url) => {
              const res = await fetch(url, {
                method: "POST",
                headers,
                body: JSON.stringify({ prompt: queryText })
              });
              const rawText = await res.text();
              return { res, rawText, url };
            };
            const primaryPromise = callWebhook(primaryUrl);
            let result = await primaryPromise;
            if (
              fallbackUrl &&
              fallbackUrl !== primaryUrl &&
              (result.res.status === 404 || result.res.status === 405 || (result.res.ok && !result.rawText.trim()))
            ) {
              setStatus("Retrying via test webhook...");
              result = await callWebhook(fallbackUrl);
            }
            let data = null;
            if (result.rawText) {
              try { data = JSON.parse(result.rawText); } catch (_) {}
            }
            if (!result.res.ok) {
              const errMsg = data?.message || result.rawText || result.res.status;
              setStatus("Workflow error: " + errMsg);
              setResponseText(`Webhook ${result.url} failed (HTTP ${result.res.status}).\n\n${result.rawText || "No response body"}`);
              finalizeWorkflowStep();
              return;
            }
            if (!result.rawText.trim()) {
              setStatus("Empty response from webhook");
              setResponseText(`Empty response from ${result.url}.\nEnsure the workflow is activated or run in test mode.`);
              finalizeWorkflowStep();
              return;
            }
            if (data?.status === "accepted" && data?.executionId) {
              asyncMode = true;
              setStatus("Workflow running...");
              startPollingResult(data.executionId, "query");
              return;
            }
            if (data?.status === "accepted" && !data?.executionId) {
              asyncMode = true;
              setStatus("Workflow running...");
              startPollingLatest("graph-query", "query");
              return;
            }
            if (typeof data?.message === "string" && data.message.toLowerCase().includes("started")) {
              asyncMode = true;
              setStatus("Workflow running...");
              startPollingLatest("graph-query", "query");
              return;
            }
            const isIntermediateResponse = data &&
              !data.answer &&
              !data.response &&
              !data.cypher &&
              (data.prompt_text || data.ollama_model || data.mcp_url);
            if (isIntermediateResponse) {
              asyncMode = true;
              setStatus("Workflow running...");
              startPollingLatest("graph-query", "query");
              return;
            }
            setWorkflowStep(4); setProgress(85);
            const answer = data?.answer || data?.response || result.rawText || "";
            setResponseText(answer);
            setResponseCypher(data?.cypher || "");
            setWorkflowStep(5); setProgress(100);
            setStatus("Request completed");
            finalizeWorkflowStep();
          } catch (err) {
            setStatus("Request failed: " + err.message);
            finalizeWorkflowStep();
          } finally {
            if (!asyncMode) {
              setIsRunning(false);
            }
          }
        };

        const handleClearGraph = async () => {
          const graphName = graphView === "MetaGraph" ? "Metagraph" : "OntoGraph";
          if (!confirm(`Delete ALL nodes with graph: ${graphName}?`)) return;
          await clearGraph(graphName);
          run();
        };

        const handleDeleteNode = async (nodeId) => {
          if (!confirm("Delete this node?")) return;
          await deleteNode(nodeId);
          setContextMenu(null);
          setSelected(null);
          run();
        };

        const editProperty = (key) => {
          if (!selected || selected.type !== "node") return;
          const current = selected.props ? selected.props[key] : undefined;
          setEditingKey(key);
          setEditingValue(JSON.stringify(current ?? ""));
        };

        const saveEdit = async () => {
          if (!selected || selected.type !== "node" || !editingKey) return;
          const value = parseInputValue(editingValue);
          const updated = await updateNodeProp(selected.id, editingKey, value);
          if (updated) {
            const label = updated.labels?.[0] || selected.label;
            setSelected(buildDetails("node", label, selected.id, updated.props));
          }
          setEditingKey(null);
          setEditingValue("");
        };

        const addProperty = async () => {
          if (!selected || selected.type !== "node") return;
          const key = prompt("Property name");
          if (!key) return;
          setEditingKey(key);
          setEditingValue("");
        };

        React.useEffect(() => { run(); }, []);

        const propEntries = selected?.props || {};
        const keySet = new Set(Object.keys(propEntries));
        if (editingKey) keySet.add(editingKey);
        const propKeys = Array.from(keySet).sort();

        const rightPanel = selected
          ? e("div", null,
              e("div", { className: "panel-title" }, "Node details"),
              e("div", { className: "chip" }, selected.label || "Node"),
              e("table", { className: "table" },
                e("thead", null,
                  e("tr", null, e("th", null, "Key"), e("th", null, "Value"))
                ),
                e("tbody", null,
                  e("tr", { key: "<id>" },
                    e("td", null, "<id>"),
                    e("td", { className: "value" }, String(selected.id))
                  ),
                  propKeys.map((k) =>
                    e("tr", { key: k },
                      e("td", null,
                        selected.type === "node" ? e("button", { className: "edit-btn", onClick: () => editProperty(k) }, "✎") : null,
                        k
                      ),
                      e("td", { className: "value" },
                        (selected.type === "node" && editingKey === k)
                          ? e("div", { className: "edit-wrap" },
                              e("input", {
                                className: "edit-input",
                                value: editingValue,
                                onChange: (ev) => setEditingValue(ev.target.value),
                                onKeyDown: (ev) => { if (ev.key === "Enter") saveEdit(); }
                              }),
                              e("button", { className: "save-btn", onClick: saveEdit }, "✔")
                            )
                          : JSON.stringify(propEntries[k])
                      )
                    )
                  )
                )
              ),
              selected.type === "node"
                ? e("button", { className: "add-btn", onClick: addProperty }, "Add property")
                : null
            )
          : e("div", { className: "empty" }, "Click a node or edge to see its properties");

        return e("div", { id: "app" },
          e("div", { id: "left" },
            e("h3", null, "Graph Viewer"),
            e("label", null, "Mode"),
            e("select", {
              value: mode,
              onChange: (ev) => setMode(ev.target.value),
              style: { width: "100%", marginTop: "6px", background: "#0f1117", color: "#e6e6e6", border: "1px solid #2a2f3a", padding: "8px", borderRadius: "6px" }
            },
              e("option", { value: "ingest" }, "Ingest Rules"),
              e("option", { value: "query" }, "Request Grammar")
            ),
            e("label", null, "Graph View"),
            e("select", {
              value: graphView,
              onChange: (ev) => {
                const v = ev.target.value;
                setGraphView(v);
                const q = buildCypher(v);
                setCypher(q);
                run(q);
              },
              style: { width: "100%", marginTop: "6px", background: "#0f1117", color: "#e6e6e6", border: "1px solid #2a2f3a", padding: "8px", borderRadius: "6px" }
            },
              e("option", { value: "OntoGraph" }, "OntoGraph"),
              e("option", { value: "MetaGraph" }, "MetaGraph")
            ),
            mode === "ingest"
              ? e("div", null,
                  e("label", null, "Rules Prompt"),
                  e("textarea", {
                    rows: 6,
                    value: rulesText,
                    placeholder: "Enter design rules here...",
                    onChange: (ev) => setRulesText(ev.target.value)
                  }),
                  e("button", { onClick: sendRules, disabled: isRunning }, "Send Rules")
                )
              : e("div", null,
                  e("label", null, "Natural Language Prompt"),
                  e("textarea", {
                    rows: 6,
                    value: queryText,
                    placeholder: "Ask about the graph (e.g., list rules for project X)...",
                    onChange: (ev) => setQueryText(ev.target.value)
                  }),
                  e("button", { onClick: requestGrammar, disabled: isRunning }, "Request Grammar")
                ),
            e("button", { className: "danger-btn", onClick: handleClearGraph, disabled: isRunning }, "Clear the Graph"),
            e("div", { className: "progress" },
              e("div", { style: { width: progress + "%" } })
            ),
            e("div", { className: "steps" },
              steps.map((s, i) => {
                const elapsed = stepTimes[i];
                const isActive = i + 1 === step;
                const live = isActive && stepStartedAtRef.current
                  ? roundSeconds(Date.now() - stepStartedAtRef.current)
                  : null;
                const suffix = elapsed !== null && elapsed !== undefined
                  ? ` (${elapsed.toFixed(1)}s)`
                  : (live !== null ? ` (${live.toFixed(1)}s)` : "");
                return e("div", { key: s, className: isActive ? "active" : "" }, s + suffix);
              })
            ),
            e("label", null, "Response"),
            e("textarea", {
              rows: 6,
              value: responseText,
              readOnly: true,
              placeholder: mode === "query" ? "Response will appear here..." : "Workflow response will appear here..."
            }),
            e("div", null,
              e("label", null, "Workflow Cypher"),
              e("textarea", {
                rows: 6,
                value: responseCypher,
                readOnly: true,
                placeholder: mode === "query"
                  ? "Cypher used to query the graph will appear here..."
                  : "Cypher used to build the graph will appear here..."
              })
            ),
            mode === "query"
              ? e("div", null,
                  e("label", null, "Cypher Query"),
                  e("textarea", {
                    rows: 8,
                    value: cypher,
                    onChange: (ev) => setCypher(ev.target.value)
                  }),
                  e("button", { onClick: run }, "Run Query")
                )
              : null,
            e("div", { className: "hint" }, "Using ", (window.GRAPH_CONFIG || {}).neo4jUri || "(no uri)"),
            e("div", { className: "status" }, status)
          ),
          e("div", { id: "viz" }),
          e("div", { id: "right", className: selected ? "open" : "" }, rightPanel),
          contextMenu
            ? e("div", { className: "context-menu", style: { left: contextMenu.x, top: contextMenu.y } },
                e("button", { onClick: () => handleDeleteNode(contextMenu.nodeId) }, "Delete")
              )
            : null
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("app"));
      root.render(e(App));
    </script>
  </body>
</html>
